/*
 *  fl#valid - File-structure validity
 *  Copyright (C) 2016  Fredrik Lindgren, a.k.a., Wisp
 *
 *  This script is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version. The following additional
 *  permissions apply:
 *
 *  Section 4: Conveying Verbatim Copies
 *  You are only required to retain any existing notices of copyright
 *  and absence of warranty.
 *
 *  This script is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this script.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*********************************************************************
 * Public interface
 ********************************************************************/

OUTER_SET fl#valid#silent = 0

DEFINE_PATCH_FUNCTION fl#valid
  RET
    valid
    failure
BEGIN
  LPF fl#valid#signature RET signature END
  PATCH_MATCH "%signature%" WITH
    "AREA" BEGIN LPF fl#valid#are RET valid failure END END

    "CRE " BEGIN LPF fl#valid#cre RET valid failure END END

    "ITM " BEGIN LPF fl#valid#itm RET valid failure END END

    "SPL " BEGIN LPF fl#valid#spl RET valid failure END END

    "%fl#null%"
    BEGIN
      valid = 0
      SPRINT failure "signature"
      LPF fl#valid#chat STR_VAR m = "WARNING: buffer is missing a signature" END
    END

    "0-byte file"
    BEGIN
      valid = 0
      SPRINT failure "empty buffer"
      LPF fl#valid#chat STR_VAR m = "WARNING: buffer is empty" END
    END

    DEFAULT
      valid = 1
      SPRINT failure ""
      LPF fl#valid#chat
        STR_VAR
          m = "fl#valid does not support buffers of type %signature%; no validation is done"
      END
  END
END

DEFINE_ACTION_FUNCTION fl#valid
  STR_VAR
    file = ""
  RET
    valid
    failure
BEGIN
  ACTION_IF "%file%" STR_CMP "" AND FILE_EXISTS_IN_GAME "%file%" BEGIN
    COPY_EXISTING "%file%" override
      LPF fl#valid RET valid failure END
    BUT_ONLY
  END ELSE WARN "WARNING: fl#valid cannot determine validity of non-existent file %file%"
END

/*********************************************************************
 * Private interface
 ********************************************************************/

OUTER_INNER_PATCH fl#valid#null BEGIN
  WRITE_ASCII 0 "" #4
  READ_ASCII 0 fl#null (4)
END

DEFINE_PATCH_FUNCTION fl#valid#signature
  RET
    signature
    version
BEGIN
  READ_ASCII 0 signature ELSE "0-byte file" (4)
  READ_ASCII 4 version ELSE "0-byte file" (4)
END

DEFINE_PATCH_FUNCTION fl#valid#chat
  STR_VAR
    m = ""
BEGIN
  PATCH_IF !fl#valid#silent BEGIN
    PATCH_PRINT "%m%"
  END
END

OUTER_SET fl#valid#eff#v1#header_length = 0x30
OUTER_SET fl#valid#eff#v2#header_length = 0x108

DEFINE_PATCH_FUNCTION fl#valid#offsets
  INT_VAR
    header_length = 0
  STR_VAR
    offset_array = ""
    whitelist_null_array = ""
    buffer_type = ""
  RET
    valid
    failure
BEGIN
  valid = 1
  SPRINT failure ""
  PHP_EACH "%offset_array%" AS start_offset => _ BEGIN
    READ_LONG  start_offset start
    PATCH_IF start < header_length &&
             !VARIABLE_IS_SET $EVAL "%whitelist_null_array%"("%start_offset%")
    BEGIN
      valid = 0
      SPRINT failure "offset too low"
      LPF fl#valid#chat
        STR_VAR
          m = EVAL "WARNING: %buffer_type% buffer has structure-start offset pointing into header"
      END
    END
    PATCH_IF start > BUFFER_LENGTH
    BEGIN
      valid = 0
      SPRINT failure "offset too high"
      LPF fl#valid#chat
        STR_VAR
          m = EVAL "WARNING: %buffer_type% buffer has structure-start offset pointing outside file length"
      END
    END
  END
END

DEFINE_PATCH_FUNCTION fl#valid#structure#sum
  INT_VAR
    size = 0
    always_read_length = "-1"
  STR_VAR
    offset_array = ""
    extended_offset_array = ""
    size_array = ""
    read_length_array = ""
    structure_length_exception_function = ""
  RET
    size
BEGIN
  PHP_EACH "%offset_array%" AS _ => count_offset BEGIN
    read_length = always_read_length > 0 ? always_read_length :
                  $EVAL "%read_length_array%"(0 "%count_offset%")
    PATCH_IF read_length = 4 BEGIN
      READ_LONG count_offset count
    END ELSE BEGIN
      READ_SHORT count_offset count
    END
    structure_size = $EVAL "%size_array%"(0 "%count_offset%")
    PATCH_IF structure_size < 0 BEGIN
      LPF "%structure_length_exception_function%" RET structure_size = length END
    END
    size += count * structure_size
  END
  PHP_EACH "%extended_offset_array%" AS offset => extended_offset BEGIN
    read_length = always_read_length > 0 ? always_read_length :
                  $EVAL "%read_length_array%"(0 "%offset_0%")
    PATCH_IF read_length = 4 BEGIN
      READ_LONG offset_0 start
    END ELSE BEGIN
      READ_SHORT offset_0 start
    END
    read_length = always_read_length > 0 ? always_read_length :
                  $EVAL "%read_length_array%"(0 "%offset_1%")
    PATCH_IF read_length = 4 BEGIN
      READ_LONG offset_1 count
    END ELSE BEGIN
      READ_SHORT offset_1 count
    END
    iteration_length = $EVAL "%size_array%"(0 "%offset_1%")
    PATCH_IF iteration_length < 0 BEGIN
      LPF "%structure_length_exception_function%" RET iteration_length = length END
    END
    FOR (i = 0; i < count; ++i) BEGIN
      read_length = always_read_length > 0 ? always_read_length :
                    $EVAL "%read_length_array%"("%offset_1%" "%extended_offset%")
      PATCH_IF read_length = 4 BEGIN
        READ_LONG start + i * iteration_length + extended_offset extended_count
      END ELSE BEGIN
        READ_SHORT start + i * iteration_length + extended_offset extended_count
      END
      extended_size = $EVAL "%size_array%"("%offset_1%" "%extended_offset%")
      PATCH_IF extended_size < 0 BEGIN
        LPF "%structure_length_exception_function%" RET extended_size = length END
      END
      size += extended_count * extended_size
    END
  END
END

DEFINE_PATCH_FUNCTION fl#valid#structure#size_check
  INT_VAR
    size = 0
  STR_VAR
    buffer_type = ""
  RET
    valid
    failure
BEGIN
  PATCH_IF size > BUFFER_LENGTH BEGIN
    valid = 0
    SPRINT failure "fewer bytes"
    buff = BUFFER_LENGTH
    LPF fl#valid#chat
      STR_VAR
        m = EVAL "WARNING: %buffer_type% buffer has fewer bytes than expected"
    END
  END
  PATCH_IF size < BUFFER_LENGTH BEGIN
    valid = 0
    SPRINT failure "more bytes"
    LPF fl#valid#chat
      STR_VAR
        m = EVAL "WARNING: %buffer_type% buffer has more bytes than expected"
    END
  END
  PATCH_IF size = BUFFER_LENGTH BEGIN
    valid = 1
    SPRINT failure ""
  END
END

/*********************************************************************
 * AREA
 ********************************************************************/

/*
 * Determines if the current buffer is a valid area.
 * Return boolean vaild
 */
DEFINE_PATCH_FUNCTION fl#valid#are
  RET
    valid
    failure
BEGIN
  LPF fl#valid#are#signature RET valid version failure END
  PATCH_FOR_EACH check IN
                 fl#valid#are#size
                 fl#valid#are#offsets
                 fl#valid#are#structure#size
  BEGIN
    PATCH_IF valid BEGIN
      LPF "%check%" STR_VAR version RET valid failure END
    END
  END
END

OUTER_SPRINT fl#valid#are#v10 "V1.0"
OUTER_SPRINT fl#valid#are#v91 "V9.1"

OUTER_SET fl#valid#are#v10#header_length = 0x11c
OUTER_SET fl#valid#are#v91#header_length = 0x12c
OUTER_SET fl#valid#are#lengths#songs = 0x90
OUTER_SET fl#valid#are#lengths#rests = 0xe4

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#offsets BEGIN
  0x54 => 0x58
  0x5c => 0x5a
  0x60 => 0x64
  0x68 => 0x6c
  0x70 => 0x74
  0x78 => 0x76
  0x7c => 0x80
  0x84 => 0x82
  0x88 => 0x8c
  0x90 => 0x92
  0xa0 => 0x9c // explored bitmap; possibly needs to be handled separately
  0xa8 => 0xa4
  0xb0 => 0xac
  0xb8 => 0xb4
  // PST and remaining offsets are handled at run-time
END

DEFINE_PATCH_MACRO fl#valid#are#v10#offsets#runtime BEGIN
  PATCH_IF ENGINE_IS pst BEGIN
    // add offsets for PST-version of AREA V1.0
    DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#offsets BEGIN
      0xc8 => 0xcc
    END
    DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#offsets#whitelist_null BEGIN
      0xc8 => _ // automap notes
    END
  END ELSE BEGIN
    // add offsets for non-PST-version of AREA V1.0
    DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#offsets BEGIN
      0xc4 => 0xc8
      0xcc => 0xd0
    END
  END
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#offsets#whitelist_null BEGIN
  0x90 => _ // tiled object flags
  0xc4 => _ // automap notes
  0xcc => _ // projectile traps
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v91#offsets BEGIN
  0x64 => 0x68
  0x6c => 0x6a
  0x70 => 0x74
  0x78 => 0x7c
  0x80 => 0x84
  0x88 => 0x86
  0x8c => 0x90
  0x94 => 0x92
  0x98 => 0x9c
  0xa0 => 0xa2
  0xb0 => 0xac // explored bitmap
  0xb8 => 0xb4
  0xc0 => 0xbc
  0xc8 => 0xc4
  0xd4 => 0xd8
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v91#offsets#whitelist_null BEGIN
  0xa0 => _ // tiled object flags
  0xd4 => _ // automap notes
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#lengths BEGIN
  0, 0x58 => 0x110 // actor
  0, 0x5a => 0xc4 // region
  0, 0x64 => 0xc8 // spawn point
  0, 0x6c => 0x68 // entrance
  0, 0x74 => 0xc0 // container
  0, 0x76 => 0x14 // item
  0, 0x80 => 0x4 // vertex
  0, 0x82 => 0xd4 // ambient
  0, 0x8c => 0x50 // variable
  0, 0x92 => 0 // FIXME: how long are these?; tiled object flag
  0, 0x9c => 0 // FIXME; explored bitmap
  0, 0xa4 => 0xc8 // door
  0, 0xac => 0x4c // animation
  0, 0xb4 => 0x6c // tiled object
  0, 0xbc => 0x90 // song entry; no count offset
  0, 0xc0 => 0xe4 // rest interruption; no count offset
  // PST and remaining lengths are handled at runtime
END

DEFINE_PATCH_MACRO fl#valid#are#v10#lengths#runtime BEGIN
  PATCH_IF ENGINE_IS pst BEGIN
    // add structure lengths for PST-version of AREA V1.0
    DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#lengths BEGIN
      0, 0xcc => 0x214 // automap note
    END
  END ELSE BEGIN
    // add structure lengths for non-PST-version of AREA V1.0
    DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#lengths BEGIN
      0, 0xc8 => 0x34 // automap note
      0, 0xd0 => 0x1c // projectile trap
    END
  END
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v91#lengths BEGIN
  0, 0x68 => 0x110 // actor
  0, 0x6a => 0xc4 // region
  0, 0x74 => 0xc8 // spawn point
  0, 0x7c => 0x68 // entrance
  0, 0x84 => 0xc0 // container
  0, 0x86 => 0x14 // item
  0, 0x90 => 0x4 // vertex
  0, 0x92 => 0xd4 // ambient
  0, 0x9c => 0x50 // variable
  0, 0xa2 => 0 // FIXME: how long are these?; tiled object flag
  0, 0xac => 0 // FIXME; explored bitmap
  0, 0xb4 => 0xc8 // door
  0, 0xbc => 0x4c // animation
  0, 0xc4 => 0x6c // tiled object
  0, 0xcc => 0x90 // song entry; no count offset
  0, 0xd0 => 0xe4 // rest interruption; no count offset
  0, 0xd8 => 0x46 // automap note
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#read_lengths BEGIN
  0, 0x54 => 4
  0, 0x58 => 2
  0, 0x5a => 2
  0, 0x5c => 4
  0, 0x60 => 4
  0, 0x64 => 4
  0, 0x68 => 4
  0, 0x6c => 4
  0, 0x70 => 4
  0, 0x74 => 2
  0, 0x76 => 2
  0, 0x78 => 4
  0, 0x7c => 4
  0, 0x80 => 2
  0, 0x82 => 2
  0, 0x84 => 4
  0, 0x88 => 4
  0, 0x8c => 4
  0, 0x90 => 2
  0, 0x92 => 2
  0, 0x9c => 4
  0, 0xa0 => 4
  0, 0xa4 => 4
  0, 0xa8 => 4
  0, 0xac => 4
  0, 0xb0 => 4
  0, 0xb4 => 4
  0, 0xb8 => 4
  0, 0xbc => 4
  0, 0xc0 => 4
  0, 0xc4 => 4
  0, 0xc8 => 4
  0, 0xcc => 4
  0, 0xd0 => 4
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v91#read_lengths BEGIN
  0, 0x64 => 4
  0, 0x68 => 2
  0, 0x6a => 2
  0, 0x6c => 4
  0, 0x70 => 4
  0, 0x74 => 4
  0, 0x78 => 4
  0, 0x7c => 4
  0, 0x80 => 4
  0, 0x84 => 2
  0, 0x86 => 2
  0, 0x88 => 4
  0, 0x8c => 4
  0, 0x90 => 2
  0, 0x92 => 2
  0, 0x94 => 4
  0, 0x98 => 4
  0, 0x9c => 4
  0, 0xa0 => 2
  0, 0xa2 => 2
  0, 0xac => 4
  0, 0xb0 => 4
  0, 0xb4 => 4
  0, 0xb8 => 4
  0, 0xbc => 4
  0, 0xc0 => 4
  0, 0xc4 => 4
  0, 0xc8 => 4
  0, 0xcc => 4
  0, 0xd0 => 4
  0, 0xd4 => 4
  0, 0xd8 => 4
END

DEFINE_PATCH_FUNCTION fl#valid#are#signature
  RET
    valid
    version
    failure
BEGIN
  SPRINT failure ""
  LPF fl#valid#signature RET signature version END
  PATCH_IF "%signature%" STR_CMP "AREA" OR
           !("%version%" STRING_EQUAL "%fl#valid#are#v10%" OR
             "%version%" STRING_EQUAL "%fl#valid#are#v91%")
  BEGIN
    valid = 0
    SPRINT failure "signature"
    LPF fl#valid#chat
      STR_VAR
        m = "WARNING: expected area buffer does not have a valid signature"
    END
  END ELSE valid = 1
END

DEFINE_PATCH_FUNCTION fl#valid#are#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#are#v10%" WHEN BUFFER_LENGTH < fl#valid#are#v10#header_length +
                                              fl#valid#are#lengths#songs +
                                              fl#valid#are#lengths#rests
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat
        STR_VAR
          m = "WARNING: area buffer V1.0 is less than required minimum size"
      END
    END

    "%fl#valid#are#v91%" WHEN BUFFER_LENGTH < fl#valid#are#v91#header_length +
                                              fl#valid#are#lengths#songs +
                                              fl#valid#are#lengths#rests
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat
        STR_VAR
          m = "WARNING: area buffer V9.1 is less than required minimum size"
      END
    END

    DEFAULT
      valid = 1
      SPRINT failure ""
  END
END

DEFINE_PATCH_FUNCTION fl#valid#are#offsets
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  valid = 1
  SPRINT failure ""
  PATCH_MATCH "%version%" WITH
    "%fl#valid#are#v10%"
    BEGIN
      DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v10#offsets BEGIN
        0xbc => 0xbc // song entries; no counts offset
        0xc0 => 0xc0 // rest interruptions; no counts offset
      END
      LPM fl#valid#are#v10#offsets#runtime
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#are#v10#header_length
        STR_VAR
          offset_array = fl#valid#are#v10#offsets
          // FIXME: read_lengths; one is a word
          whitelist_null_array = fl#valid#are#v10#offsets#whitelist_null
          buffer_type = area
        RET
          valid
          failure
      END
    END

    "%fl#valid#are#v91%"
    BEGIN
      DEFINE_ASSOCIATIVE_ARRAY fl#valid#are#v91#offsets BEGIN
        0xcc => 0xcc // song entries; no counts offset
        0xd0 => 0xd0 // rest interruptions; no counts offset
      END
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#are#v91#header_length
        STR_VAR
          offset_array = fl#valid#are#v91#offsets
          whitelist_null_array = fl#valid#are#v91#offsets#whitelist_null
          buffer_type = area
        RET
          valid
          failure
      END
    END

    DEFAULT
  END
END

DEFINE_PATCH_FUNCTION fl#valid#are#structure#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#are#v10%"
    BEGIN
      LPM fl#valid#are#v10#offsets#runtime
      LPM fl#valid#are#v10#lengths#runtime
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#are#v10#header_length + 0x90 + 0xe4 // FIXME: hack
        STR_VAR
          offset_array = fl#valid#are#v10#offsets
          size_array = fl#valid#are#v10#lengths
          read_length_array = fl#valid#are#v10#read_lengths
        RET
          size
      END
    END

    "%fl#valid#are#v91%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#are#v91#header_length + 0x90 + 0xe4 // FIXME: hack
        STR_VAR
          offset_array = fl#valid#are#v91#offsets
          size_array = fl#valid#are#v91#lengths
          read_length_array = fl#valid#are#v91#read_lengths
        RET
          size
      END
    END

    DEFAULT
      size = 0
  END
  LPF fl#valid#structure#size_check
    INT_VAR
      size
    STR_VAR
      buffer_type = area
    RET
      valid
      failure
  END
END

/*********************************************************************
 * CRE
 ********************************************************************/

/*
 * Determines if the current buffer is a valid creature.
 * Return boolean valid
 */
DEFINE_PATCH_FUNCTION fl#valid#cre
  RET
    valid
    failure
BEGIN
  LPF fl#valid#cre#signature RET valid version failure END
  PATCH_FOR_EACH check IN
                 fl#valid#cre#size
                 fl#valid#cre#offsets
                 fl#valid#cre#structure#size
                 // fl#valid#cre#structure#contiguousness
  BEGIN
    PATCH_IF valid BEGIN
      LPF "%check%" STR_VAR version RET valid failure END
    END
  END
END

OUTER_SPRINT fl#valid#cre#v10 "V1.0"
OUTER_SPRINT fl#valid#cre#v12 "V1.2"
OUTER_SPRINT fl#valid#cre#v22 "V2.2"
OUTER_SPRINT fl#valid#cre#v90 "V9.0"

OUTER_SET fl#valid#cre#v10#header_length = 0x2d4
OUTER_SET fl#valid#cre#v12#header_length = 0x378
OUTER_SET fl#valid#cre#v22#header_length = 0x62e
OUTER_SET fl#valid#cre#v90#header_length = 0x33c

OUTER_SET fl#valid#cre#v10#slots_length = 0x50
OUTER_SET fl#valid#cre#v12#slots_length = 0x60
OUTER_SET fl#valid#cre#v22#slots_length = 0x68
OUTER_SET fl#valid#cre#v90#slots_length = 0x50

OUTER_SET fl#valid#cre#v22#spell_mem_info = 0x258

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v10#offsets BEGIN
  0x2a0 => 0x2a4
  0x2a8 => 0x2ac
  0x2b0 => 0x2b4
  0x2bc => 0x2c0
  0x2c4 => 0x2c8
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v12#offsets BEGIN
  0x344 => 0x348
  0x34c => 0x350
  0x354 => 0x358
  0x360 => 0x364
  0x368 => 0x36c
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v22#offsets BEGIN
  0x3ba => 0x4b6
  0x3be => 0x4ba
  0x3c2 => 0x4be
  0x3c6 => 0x4c2
  0x3ca => 0x4c6
  0x3ce => 0x4ca
  0x3d2 => 0x4ce
  0x3d6 => 0x4d2
  0x3da => 0x4d6
  0x3de => 0x4da
  0x3e2 => 0x4de
  0x3e6 => 0x4e2
  0x3ea => 0x4e6
  0x3ee => 0x4ea
  0x3f2 => 0x4ee
  0x3f6 => 0x4f2
  0x3fa => 0x4f6
  0x3fe => 0x4fa
  0x402 => 0x4fe
  0x406 => 0x502
  0x40a => 0x506
  0x40e => 0x50a
  0x412 => 0x50e
  0x416 => 0x512
  0x41a => 0x516
  0x41e => 0x51a
  0x422 => 0x51e
  0x426 => 0x522
  0x42a => 0x526
  0x42e => 0x52a
  0x432 => 0x52e
  0x436 => 0x532
  0x43a => 0x536
  0x43e => 0x53a
  0x442 => 0x53e
  0x446 => 0x542
  0x44a => 0x546
  0x44e => 0x54a
  0x452 => 0x54e
  0x456 => 0x552
  0x45a => 0x556
  0x45e => 0x55a
  0x462 => 0x55e
  0x466 => 0x562
  0x46a => 0x566
  0x46e => 0x56a
  0x472 => 0x56e
  0x476 => 0x572
  0x47a => 0x576
  0x47e => 0x57a
  0x482 => 0x57e
  0x486 => 0x582
  0x48a => 0x586
  0x48e => 0x58a
  0x492 => 0x58e
  0x496 => 0x592
  0x49a => 0x596
  0x49e => 0x59a
  0x4a2 => 0x59e
  0x4a6 => 0x5a2
  0x4aa => 0x5a6
  0x4ae => 0x5aa

  0x4b2 => 0x5ae
  0x5b2 => 0x5d6
  0x5b6 => 0x5da
  0x5ba => 0x5de
  0x5be => 0x5e2
  0x5c2 => 0x5e6
  0x5c6 => 0x5ea
  0x5ca => 0x5ee
  0x5ce => 0x5f2
  0x5d2 => 0x5f6

  0x5fa => 0x5fe
  0x602 => 0x606
  0x60a => 0x60e
  0x616 => 0x61a
  0x61e => 0x622
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v90#offsets BEGIN
  0x308 => 0x30c
  0x310 => 0x314
  0x318 => 0x31c
  0x324 => 0x328
  0x32c => 0x330
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v10#lengths BEGIN
  0, 0x2a4 => 0xc
  0, 0x2ac => 0x10
  0, 0x2b4 => 0xc
  0, 0x2c0 => 0x14
  0, 0x2c8 => "-1"
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v12#lengths BEGIN
  0, 0x298 => 0x26 // TODO: verify; IESDP is inconsistent
  0, 0x348 => 0xc
  0, 0x350 => 0x10
  0, 0x358 => 0xc
  0, 0x364 => 0x14
  0, 0x36c => "-1"
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v22#lengths BEGIN
  0, 0x4b6 => 0x10
  0, 0x4ba => 0x10
  0, 0x4be => 0x10
  0, 0x4c2 => 0x10
  0, 0x4c6 => 0x10
  0, 0x4ca => 0x10
  0, 0x4ce => 0x10
  0, 0x4d2 => 0x10
  0, 0x4d6 => 0x10
  0, 0x4da => 0x10
  0, 0x4de => 0x10
  0, 0x4e2 => 0x10
  0, 0x4e6 => 0x10
  0, 0x4ea => 0x10
  0, 0x4ee => 0x10
  0, 0x4f2 => 0x10
  0, 0x4f6 => 0x10
  0, 0x4fa => 0x10
  0, 0x4fe => 0x10
  0, 0x502 => 0x10
  0, 0x506 => 0x10
  0, 0x50a => 0x10
  0, 0x50e => 0x10
  0, 0x512 => 0x10
  0, 0x516 => 0x10
  0, 0x51a => 0x10
  0, 0x51e => 0x10
  0, 0x522 => 0x10
  0, 0x526 => 0x10
  0, 0x52a => 0x10
  0, 0x52e => 0x10
  0, 0x532 => 0x10
  0, 0x536 => 0x10
  0, 0x53a => 0x10
  0, 0x53e => 0x10
  0, 0x542 => 0x10
  0, 0x546 => 0x10
  0, 0x54a => 0x10
  0, 0x54e => 0x10
  0, 0x552 => 0x10
  0, 0x556 => 0x10
  0, 0x55a => 0x10
  0, 0x55e => 0x10
  0, 0x562 => 0x10
  0, 0x566 => 0x10
  0, 0x56a => 0x10
  0, 0x56e => 0x10
  0, 0x572 => 0x10
  0, 0x576 => 0x10
  0, 0x57a => 0x10
  0, 0x57e => 0x10
  0, 0x582 => 0x10
  0, 0x586 => 0x10
  0, 0x58a => 0x10
  0, 0x58e => 0x10
  0, 0x592 => 0x10
  0, 0x596 => 0x10
  0, 0x59a => 0x10
  0, 0x59e => 0x10
  0, 0x5a2 => 0x10
  0, 0x5a6 => 0x10
  0, 0x5aa => 0x10

  0, 0x5ae => 0x10
  0, 0x5d6 => 0x10
  0, 0x5da => 0x10
  0, 0x5de => 0x10
  0, 0x5e2 => 0x10
  0, 0x5e6 => 0x10
  0, 0x5ea => 0x10
  0, 0x5ee => 0x10
  0, 0x5f2 => 0x10
  0, 0x5f6 => 0x10

  0, 0x5fe => 0x10
  0, 0x606 => 0x10
  0, 0x60e => 0x10
  0, 0x61a => 0x14
  0, 0x622 => "-1"
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v90#lengths BEGIN
  0, 0x30c => 0xc
  0, 0x314 => 0x10
  0, 0x31c => 0xc
  0, 0x328 => 0x14
  0, 0x330 => "-1"
END

DEFINE_PATCH_FUNCTION fl#valid#cre#eff#length
  RET
    length
BEGIN
  READ_BYTE 0x33 eff_version
  PATCH_IF eff_version = 0 BEGIN
    length = fl#valid#eff#v1#header_length
  END ELSE BEGIN
    length = fl#valid#eff#v2#header_length
  END
END

DEFINE_PATCH_FUNCTION fl#valid#cre#signature
  RET
    valid
    version
    failure
BEGIN
  SPRINT failure ""
  LPF fl#valid#signature RET signature version END
  PATCH_IF "%signature%" STR_CMP "CRE " OR
           !("%version%" STRING_EQUAL "%fl#valid#cre#v10%" OR
             "%version%" STRING_EQUAL "%fl#valid#cre#v12%" OR
             "%version%" STRING_EQUAL "%fl#valid#cre#v22%" OR
             "%version%" STRING_EQUAL "%fl#valid#cre#v90%")
  BEGIN
    valid = 0
    SPRINT failure "signature"
    LPF fl#valid#chat
      STR_VAR
        m = "WARNING: expected creature buffer does not have a valid signature"
    END
  END ELSE valid = 1
END

DEFINE_PATCH_FUNCTION fl#valid#cre#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#cre#v10%" WHEN BUFFER_LENGTH < fl#valid#cre#v10#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat
        STR_VAR
          m = "WARNING: creature buffer V1.0 is less than required minimum size"
      END
    END

    "%fl#valid#cre#v12%" WHEN BUFFER_LENGTH < fl#valid#cre#v12#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat
        STR_VAR
          m = "WARNING: creature buffer V1.2 is less than required minimum size"
      END
    END

    "%fl#valid#cre#v22%" WHEN BUFFER_LENGTH < fl#valid#cre#v22#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat
        STR_VAR
          m = "WARNING: creature buffer V2.2 is less than required minimum size"
      END
    END

    "%fl#valid#cre#v90%" WHEN BUFFER_LENGTH < fl#valid#cre#v90#header_length
    BEGIN
      valid = 0
      LPF fl#valid#chat
        STR_VAR
          m = "WARNING: creature buffer V9.0 is less than required minimum size"
      END
    END

    DEFAULT
      valid = 1
      SPRINT failure ""
  END
END

DEFINE_PATCH_FUNCTION fl#valid#cre#offsets
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  valid = 1
  SPRINT failure ""
  PATCH_MATCH "%version%" WITH
    "%fl#valid#cre#v10%"
    BEGIN
      DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v10#offsets BEGIN
        0x2b8 => 0x2c0 // Add the item slots offset to the array
      END
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#cre#v10#header_length
        STR_VAR
          offset_array = fl#valid#cre#v10#offsets
          buffer_type = creature
        RET
          valid
          failure
      END
    END

    "%fl#valid#cre#v12%"
    BEGIN
      DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v12#offsets BEGIN
        0x35c => 0x364 // Add the item slots offset to the array
      END
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#cre#v12#header_length
        STR_VAR
          offset_array = fl#valid#cre#v12#offsets
          buffer_type = creature
        RET
          valid
      END
    END

    "%fl#valid#cre#v22%"
    BEGIN
      DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v22#offsets BEGIN
        0x612 => 0x61a // Add the item slots offset to the array
      END
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#cre#v22#header_length
        STR_VAR
          offset_array = fl#valid#cre#v22#offsets
          buffer_type = creature
        RET
          valid
          failure
      END
    END

    "%fl#valid#cre#v90%"
    BEGIN
      DEFINE_ASSOCIATIVE_ARRAY fl#valid#cre#v90#offsets BEGIN
        0x320 => 0x328 // Add the item slots offset to the array
      END
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#cre#v90#header_length
        STR_VAR
          offset_array = fl#valid#cre#v90#offsets
          buffer_type = creature
        RET
          valid
          failure
      END
    END

    DEFAULT
  END
END

DEFINE_PATCH_FUNCTION fl#valid#cre#structure#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#cre#v10%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#cre#v10#header_length + fl#valid#cre#v10#slots_length
          always_read_length = 4
        STR_VAR
          offset_array = fl#valid#cre#v10#offsets
          size_array = fl#valid#cre#v10#lengths
          structure_length_exception_function = fl#valid#cre#eff#length
        RET
          size
      END
    END

    "%fl#valid#cre#v12%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#cre#v12#header_length + fl#valid#cre#v12#slots_length
          always_read_length = 4
        STR_VAR
          offset_array = fl#valid#cre#v12#offsets
          size_array = fl#valid#cre#v12#lengths
          structure_length_exception_function = fl#valid#cre#eff#length
        RET
          size
      END
    END

    "%fl#valid#cre#v22%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#cre#v22#header_length +
                 fl#valid#cre#v22#slots_length +
                 fl#valid#cre#v22#spell_mem_info
          always_read_length = 4
        STR_VAR
          offset_array = fl#valid#cre#v22#offsets
          size_array = fl#valid#cre#v22#lengths
          structure_length_exception_function = fl#valid#cre#eff#length
        RET
          size
      END
    END

    "%fl#valid#cre#v90%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#cre#v90#header_length + fl#valid#cre#v90#slots_length
          always_read_length = 4
        STR_VAR
          offset_array = fl#valid#cre#v90#offsets
          size_array = fl#valid#cre#v90#lengths
          structure_length_exception_function = fl#valid#cre#eff#length
        RET
          size
      END
    END

    DEFAULT
      size = 0
  END
  LPF fl#valid#structure#size_check
    INT_VAR
      size
    STR_VAR
      buffer_type = creature
    RET
      valid
      failure
  END
END

/*********************************************************************
 * ITM
 ********************************************************************/

/*
 * Determines if the current buffer is a valid item.
 * Return boolean valid
 */
DEFINE_PATCH_FUNCTION fl#valid#itm
  RET
    valid
    failure
BEGIN
  LPF fl#valid#itm#signature RET valid version failure END
  PATCH_FOR_EACH check IN
                 fl#valid#itm#size
                 fl#valid#itm#offsets
                 fl#valid#itm#structure#size
  BEGIN
    PATCH_IF valid BEGIN
      LPF "%check%" STR_VAR version RET valid failure END
    END
  END
END

OUTER_SPRINT fl#valid#itm#v1 "V1  "
OUTER_SPRINT fl#valid#itm#v11 "V1.1"
OUTER_SPRINT fl#valid#itm#v20 "V2.0"

OUTER_SET fl#valid#itm#v1#header_length = 0x72
OUTER_SET fl#valid#itm#v11#header_length = 0x9a
OUTER_SET fl#valid#itm#v20#header_length = 0x82

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#itm#offsets BEGIN
  0x64 => 0x68
  0x6a => 0x70
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#itm#extended_offsets BEGIN
  0x64, 0x68 => 0x1e
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#itm#lengths BEGIN
  0, 0x68 => 0x38
  0, 0x70 => fl#valid#eff#v1#header_length
  0x68, 0x1e => fl#valid#eff#v1#header_length
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#itm#read_lengths BEGIN
  0, 0x64 => 4
  0, 0x68 => 2
  0, 0x70 => 2
  0x68, 0x1e => 2
END

DEFINE_PATCH_FUNCTION fl#valid#itm#signature
  RET
    valid
    version
    failure
BEGIN
  SPRINT failure ""
  LPF fl#valid#signature RET signature version END
  PATCH_IF "%signature%" STR_CMP "ITM " OR
           !("%version%" STRING_EQUAL "%fl#valid#itm#v1%" OR
             "%version%" STRING_EQUAL "%fl#valid#itm#v11%" OR
             "%version%" STRING_EQUAL "%fl#valid#itm#v20%")
  BEGIN
    valid = 0
    SPRINT failure "signature"
    LPF fl#valid#chat STR_VAR m = "WARNING: expected item buffer does not have a valid signature" END
  END ELSE valid = 1
END

DEFINE_PATCH_FUNCTION fl#valid#itm#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#itm#v1%" WHEN BUFFER_LENGTH < fl#valid#itm#v1#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat STR_VAR m = "WARNING: item buffer V1 is less than required minimum size" END
    END

    "%fl#valid#itm#v11%" WHEN BUFFER_LENGTH < fl#valid#itm#v11#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat STR_VAR m = "WARNING: item buffer V1.1 is less than required minimum size" END
    END

    "%fl#valid#itm#v20%" WHEN BUFFER_LENGTH < fl#valid#itm#v20#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat STR_VAR m = "WARNING: item buffer V2.0 is less than required minimum size" END
    END

    DEFAULT
      valid = 1
      SPRINT failure ""
  END
END

DEFINE_PATCH_FUNCTION fl#valid#itm#offsets
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  valid = 1
  SPRINT failure ""
  PATCH_MATCH "%version%" WITH
    "%fl#valid#itm#v1%"
    BEGIN
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#itm#v1#header_length
        STR_VAR
          offset_array = fl#valid#itm#offsets
          buffer_type = item
        RET
          valid
          failure
      END
    END

    "%fl#valid#itm#v11%"
    BEGIN
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#itm#v11#header_length
        STR_VAR
          offset_array = fl#valid#itm#offsets
          buffer_type = item
        RET
          valid
          failure
      END
    END

    "%fl#valid#itm#v20%"
    BEGIN
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#itm#v20#header_length
        STR_VAR
          offset_array = fl#valid#itm#offsets
          buffer_type = item
        RET
          valid
          failure
      END
    END

    DEFAULT
  END
END

DEFINE_PATCH_FUNCTION fl#valid#itm#structure#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#itm#v1%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#itm#v1#header_length
        STR_VAR
          offset_array = fl#valid#itm#offsets
          extended_offset_array = fl#valid#itm#extended_offsets
          size_array = fl#valid#itm#lengths
          read_length_array = fl#valid#itm#read_lengths
        RET
          size
      END
    END

    "%fl#valid#itm#v11%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#itm#v11#header_length
        STR_VAR
          offset_array = fl#valid#itm#offsets
          extended_offset_array = fl#valid#itm#extended_offsets
          size_array = fl#valid#itm#lengths
          read_length_array = fl#valid#itm#read_lengths
        RET
          size
      END
    END

    "%fl#valid#itm#v20%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#itm#v20#header_length
        STR_VAR
          offset_array = fl#valid#itm#offsets
          extended_offset_array = fl#valid#itm#extended_offsets
          size_array = fl#valid#itm#lengths
          read_length_array = fl#valid#itm#read_lengths
        RET
          size
      END
    END

    DEFAULT
      size = 0
  END
  LPF fl#valid#structure#size_check
    INT_VAR
      size
    STR_VAR
      buffer_type = item
    RET
      valid
      failure
  END
END

/*********************************************************************
 * SPL
 ********************************************************************/

/*
 * Determines if the current buffer is a valid spell.
 * Return boolean valid
 */
DEFINE_PATCH_FUNCTION fl#valid#spl
  RET
    valid
    failure
BEGIN
  LPF fl#valid#spl#signature RET valid version failure END
  PATCH_FOR_EACH check IN
                 fl#valid#spl#size
                 fl#valid#spl#offsets
                 fl#valid#spl#structure#size
  BEGIN
    PATCH_IF valid BEGIN
      LPF "%check%" STR_VAR version RET valid failure END
    END
  END
END

OUTER_SPRINT fl#valid#spl#v1 "V1  "
OUTER_SPRINT fl#valid#spl#v20 "V2.0"

OUTER_SET fl#valid#spl#v1#header_length = 0x72
OUTER_SET fl#valid#spl#v20#header_length = 0x82

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#spl#offsets BEGIN
  0x64 => 0x68
  0x6a => 0x70
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#spl#offsets BEGIN
  0x64 => 0x68
  0x6a => 0x70
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#spl#extended_offsets BEGIN
  0x64, 0x68 => 0x1e
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#spl#lengths BEGIN
  0, 0x68 => 0x28
  0, 0x70 => fl#valid#eff#v1#header_length
  0x68, 0x1e => fl#valid#eff#v1#header_length
END

ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#valid#spl#read_lengths BEGIN
  0, 0x64 => 4
  0, 0x68 => 2
  0, 0x70 => 2
  0x68, 0x1e => 2
END

DEFINE_PATCH_FUNCTION fl#valid#spl#signature
  RET
    valid
    version
    failure
BEGIN
  SPRINT failure ""
  LPF fl#valid#signature RET signature version END
  PATCH_IF "%signature%" STR_CMP "SPL " OR
           !("%version%" STRING_EQUAL "%fl#valid#spl#v1%" OR
             "%version%" STRING_EQUAL "%fl#valid#spl#v20%")
  BEGIN
    valid = 0
    SPRINT failure "signature"
    LPF fl#valid#chat STR_VAR m = "WARNING: expected spell buffer does not have a valid signature" END
  END ELSE valid = 1
END

DEFINE_PATCH_FUNCTION fl#valid#spl#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#spl#v1%" WHEN BUFFER_LENGTH < fl#valid#spl#v1#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat STR_VAR m = "WARNING: spell buffer V1 is less than required minimum size" END
    END

    "%fl#valid#spl#v20%" WHEN BUFFER_LENGTH < fl#valid#spl#v20#header_length
    BEGIN
      valid = 0
      SPRINT failure "minimum size"
      LPF fl#valid#chat STR_VAR m = "WARNING: spell buffer V2.0 is less than required minimum size" END
    END

    DEFAULT
      valid = 1
      SPRINT failure ""
  END
END

DEFINE_PATCH_FUNCTION fl#valid#spl#offsets
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  valid = 1
  SPRINT failure ""
  PATCH_MATCH "%version%" WITH
    "%fl#valid#spl#v1%"
    BEGIN
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#spl#v1#header_length
        STR_VAR
          offset_array = fl#valid#spl#offsets
          buffer_type = spell
        RET
          valid
          failure
      END
    END

    "%fl#valid#spl#v20%"
    BEGIN
      LPF fl#valid#offsets
        INT_VAR
          header_length = fl#valid#spl#v20#header_length
        STR_VAR
          offset_array = fl#valid#spl#offsets
          buffer_type = spell
        RET
          valid
          failure
      END
    END

    DEFAULT
  END
END

DEFINE_PATCH_FUNCTION fl#valid#spl#structure#size
  STR_VAR
    version = ""
  RET
    valid
    failure
BEGIN
  PATCH_MATCH "%version%" WITH
    "%fl#valid#spl#v1%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#spl#v1#header_length
        STR_VAR
          offset_array = fl#valid#spl#offsets
          extended_offset_array = fl#valid#spl#extended_offsets
          size_array = fl#valid#spl#lengths
          read_length_array = fl#valid#spl#read_lengths
        RET
          size
      END
    END

    "%fl#valid#spl#v20%"
    BEGIN
      LPF fl#valid#structure#sum
        INT_VAR
          size = fl#valid#spl#v20#header_length
        STR_VAR
          offset_array = fl#valid#spl#offsets
          extended_offset_array = fl#valid#spl#extended_offsets
          size_array = fl#valid#spl#lengths
          read_length_array = fl#valid#spl#read_lengths
        RET
          size
      END
    END

    DEFAULT
      size = 0
  END
  LPF fl#valid#structure#size_check
    INT_VAR
      size
    STR_VAR
      buffer_type = spell
    RET
      valid
      failure
  END
END
